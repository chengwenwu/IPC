# 一、编译

1、需要预先安装 `g++`。

2、当前目录下执行 `make`，将会生成semA和semB两个文件。

# 二、运行

1、分别在两个终端执行 `./semA`和 `./semB`

2、将会看到如下打印：

> semA打印：
> A write success
> read from mem: B
> timer P:: Resource temporarily unavailable
> A EndA write success
> read from mem: B
> A End

> semB打印：
> read from mem: A
> write to mem, and B End

3、可以使用 `ipcs -a` 查看所有共享内存、消息队列及信号量，使用 `ipcrm -a`清除所有ipc。

4、如果出现共享内存已经释放了，但是 `ipcs -m`仍然能够查到，且nattch不为0的情况，可以使用 `ipcs -mp`查看哪个进程还在用该共享内存，并将该进程kill，即可。

# 三、原理解释

## 1、信号量原理

- 主要用来管理和分配系统资源。
- 可以理解成一个全局变量，在初始化的时候，可以为其赋值（大于等于0的值），相当于告诉系统，我有多少个资源。
- 当有进程申请使用资源时，如果资源数量不为0，则资源数量就减1；否则等待，直到有进程释放或者产生资源。
- 当进程释放或者产生资源时，资源数量加1。

## 2、示例场景

- 进程A启动，延时3s，后向共享内存写入字母	`A`，延时3s主要是让进程B，在进行P操作的时候阻塞住。
- 进程B启动，从共享内存读取到 `A`之后，延时3s，主要是让进程A在P操作的时候阻塞住。
- 进程B，延时结束，向共享内存写入 `B`，后进行V操作，允许A进行读取。
- 进程A，继续进行定时P操作，由于此时没有进程进行V操作，所以在5s后P操作超时，进程A结束。

## 3、实现介绍

- 信号量只是进程之间同步的手段，并不能传递具体的数据，所以我们使用共享内存来传递数据。主要考虑到，消息队列其实已经有了同步机制，没必要在用信号量进行同步。

# 四、参考链接

[https://www.softprayog.in/programming/system-v-semaphores]()
